# Nginxの設定ファイルはデフォルトで２つあり、以下の順番で読み込まれます。
# /etc/nginx/nginx.conf,/etc/nginx/conf.d/default.conf

# upstream:アプリケーションサーバーの指定
# プロキシ先の指定
# Nginxが受け取ったリクエストをバックエンドのpumaに送信
# ソケット(ざっくりネットワークとの接続口)通信したいのでpuma.sockを指定
# ソケットは機器間の通信やプロセス(プログラムの処理)間の通信に使用されるインターフェイス
# サーバ（要求を待ち続けるコンピュータ）の中の実行中のプログラムは、通常サーバーソケットと
# データ送受信用のソケットの二つにバインドされる。
# 別のパソコンからサーバーへ通信を開始したい時には、まずアクセスする際は、サーバソケットに対して、通信を投げる。
# サーバソケットから別のパソコンへの返信には、データ送受信用ソケットに関する情報が含まれているのが普通。
# それを受けた別のパソコンは、サーバとデータの送受信が出来るようになる。
# ここでソケットと実行中のプログラムを結びつける事をバインドと言う
# サーバーのIPアドレス（あるいはサイト名）とサーバーソケットのポート番号を指定して通信を開始する
# データ送受信用ソケットは状況に応じて増えたり減ったりする
# Unixドメインソケットの設定。puma.rbのソケット設定(puma.sock)の絶対パスを記載。
# ここのmyappはDockerfileで記述したWORKDIR /myapp

upstream rails_app {
  server unix:///rails_app/tmp/sockets/puma.sock;
}

# ソケット通信とは
# インターネットはTCP/IPと呼ぶ通信プロトコルを利用しますが、そのTCP/IPをプログラムから利用するには、
# プログラムの世界とTCP/IPの世界を結ぶ特別な出入り口が必要となります。 
# その出入り口となるのがソケット(Socket)であり、TCP/IPのプログラミング上の大きな特徴とのことで、
# 普段利用しているHTTP通信もソケット通信

# Unixドメインソケット:
# 「UNIXドメインソケット」とは、LinuxなどのUNIX系OS（オペレーティングシステム）
# で実行されるプロセス間のデータ通信の終点に使われるインターフェースのことをいう。LinuxなどのUNIX系OSは、
# 各種デバイスの入出力にデバイスファイルというインターフェースを利用するため、
# 一般のファイルを読み書きするのと同じ手順で周辺機器を操作できる。ところが、プロセス同士がネットワーク経由で通信するときには、
# ファイル・インターフェースを拡張した「ソケット」というインターフェースが必要になる。
# 通常インターネットで利用しているソケット通信（INETドメインソケット通信）とは異なり、
# ネットワーク経由ではないローカルマシン上のプロセスが利用するソケットが、UNIXドメインソケットである。

# バーチャルホストは、一台のサーバーで仮想的に複数のドメインを運用するサーバー技術の一種で、
# 主にメールサーバーやWebサーバーなどで利用されています。
# メールサーバーやWebサーバーを運営する場合、一般的にドメインの数を上回るサーバーを用意することが多いのですが、
# バーチャルホスト機能を利用することで、1つのサーバー上で複数ドメインを同時に運用することができるようになります。
# このため、IPアドレスの節約効果やサーバー機器を減らすことで運用コストの削減などのメリットがあります。

# Nginxの設定ファイル内の「server」や「listen」、「location」などの項目を「ディレクティブ」といいます。
# server:サーバー情報を定義。デフォルトのバーチャルホストの設定。
server {
  # listen:バーチャルホストが接続を許可するポート番号やIPアドレスを定義
  listen 80;
  # server_name:アクセスを受け付けるURL。
  # localhost、またはロードバランサーのDNSなど。
  server_name localhost;
  # server_name 52.69.235.20;
  # varディレクトリ:ログファイルやキャッシュファイルなどの一時的なデータを残しおく為のディレクトリ
  # tmpディレクトリと違うのは、再起動しても残る
  # access_log:アクセスログの出力先を設定 (/var/log配下だとわかりやすい)
  access_log /var/log/nginx/access.log;
  # error_log:エラーログの出力先を設定 (/var/log配下だとわかりやすい)
  # エラーが起きたとき:cat /var/log/nginx/error.logを見てデバッグしましょう
  error_log  /var/log/nginx/error.log;
  # root:アプリのルートディレクトリ(公開するディレクトリ)を定義。ドキュメントルートの指定
  # ドキュメントルートとは、Webサーバにアクセスがあった際に参照するディレクトリのことです。
  # 静的ファイル（画像など）のパスをドキュメントルートに設定
  # 静的コンテンツは「(Railsアプリケーションのルート)\public\」ディレクトリに格納されています。
  root /rails_app/public;
  # Nginxが受信可能なリクエストボディの量を指定
  client_max_body_size 100m;
  # error_page:ステータスコードに応じて表示するページを指定
  error_page 404             /404.html;
  error_page 505 502 503 504 /500.html;
  # try_files:ファイルが存在するかを確認
  # ドキュメントルート配下を以下の先頭から順番に辿る
  # 指定したファイルパスがある場合はリダイレクト、ない場合はその次のファイルパスへと繰り返し、
  # 最後までない場合は最後に指定されたURIへとリダイレクト
  # try_files  $uri/index.html $uri @myapp;
  try_files  $uri/index.html $uri @rails_app;
  # HTTP通信のタイムアウトを待つ秒数を指定
  keepalive_timeout 5;

# $: 変数を展開している。Nginxではもともと定義されている予約語的な変数がある。
# 今回はほとんど予約語を使っている。

  # リバースプロキシ関連の設定
  # 上記の@myappが呼び出された場合のみ以下の設定を読み込む
  location @rails_app {
    # proxy_set_header:アプリケーションサーバーに送信するヘッダを定義
    # X-Real-IP $remote_addr:X-Real-IPで送信元を判別、$remote_addrで送信元IPを取得
    proxy_set_header X-Real-IP $remote_addr;
    # X-Forwarded-For $proxy_add_x_forwarded_for:リクエストが経由したアドレス全てを指定
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    # Host $http_host:ユーザーリクエストに含まれるホスト名を指定
    proxy_set_header Host $http_host;
    # proxy_pass 転送先URI:リクエストを転送先URIにプロキシ**する。
    # 今回はupstreamでpumaとして定義したpuma.sockに転送。
    proxy_pass http://rails_app;
  }
}